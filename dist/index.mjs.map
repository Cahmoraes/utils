{"version":3,"sources":["../src/utils/path.ts","../src/utils/log.ts","../src/utils/pipe.ts","../src/utils/createPipe.ts","../src/utils/asyncPipe.ts","../src/utils/createAsyncPipe.ts","../src/utils/memo.ts","../src/utils/partialize.ts","../src/utils/typeOf.ts","../src/utils/isPrimitive.ts","../src/utils/curry.ts","../src/utils/debounce.ts","../src/utils/takeUntil.ts","../src/utils/deepFreeze.ts","../src/utils/mixin.ts","../src/utils/checkInterface.ts"],"sourcesContent":["/**\n * Resolve internal Objects and Arrays paths. Return null when path not exists.\n * @date 08/10/2022 - 16:32:10\n *\n * @param {unknown} module - Object or Array\n * @param {string} pathString Path to property: 'addresses.0.street'\n * @returns {(T | null)} Existing property or null if none\n */\n\nfunction isKeyOf(\n  anObject: object,\n  aKey: string,\n): aKey is keyof typeof anObject {\n  return Reflect.has(anObject, aKey)\n}\n\nexport const path = <T>(module: unknown, pathString: string): T | null => {\n  if (!module) return null\n\n  const [firstPath, ...paths] = pathString.split('.')\n  if (!isKeyOf(module, firstPath)) return null\n  let fullPath = module[firstPath]\n\n  for (const path of paths) {\n    if (!fullPath) return null\n    fullPath = fullPath[path]\n  }\n\n  return fullPath\n}\n","/**\r\n * Log values\r\n * @date 08/10/2022 - 16:27:16\r\n *\r\n * @param {...unknown[]} args Parameters to log\r\n */\r\nexport const log = (...args: unknown[]) => console.log(...args)\r\n","/**\r\n * Apply pipeline to a value\r\n * @date 18/10/2022 - 10:23:41\r\n *\r\n * @param {A} value Value that will transformed by pipeline\r\n * @param {...operations[]} operations Function or functions to pipeline\r\n * @returns Value transformed by pipeline\r\n */\r\n\r\nexport function pipe<A, B>(value: A, op1: (input: A) => B): B\r\n\r\nexport function pipe<A, B, C>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n): C\r\n\r\nexport function pipe<A, B, C, D>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n): D\r\n\r\nexport function pipe<A, B, C, D, E>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n): E\r\n\r\nexport function pipe<A, B, C, D, E, F>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n): F\r\n\r\nexport function pipe<A, B, C, D, E, F, G>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n): G\r\n\r\nexport function pipe<A, B, C, D, E, F, G, H>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n): H\r\n\r\nexport function pipe<A, B, C, D, E, F, G, H, I>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n  op8: (input: H) => I,\r\n): I\r\n\r\nexport function pipe<A, B, C, D, E, F, G, H, I, J>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n  op8: (input: H) => I,\r\n  op9: (input: I) => J,\r\n): J\r\n\r\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\r\n  value: A,\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n  op8: (input: H) => I,\r\n  op9: (input: I) => J,\r\n  op10: (input: J) => K,\r\n): K\r\n\r\nexport function pipe(\r\n  value: any,\r\n  ...operations: readonly ((input: any) => any)[]\r\n) {\r\n  return operations.reduce((acc, fn) => fn(acc), value)\r\n}\r\n","/**\r\n * Apply pipeline to a value\r\n * @date 08/10/2022 - 16:35:18\r\n *\r\n * @param {...operations[]} operations Function or functions to pipeline\r\n * @returns {<T>(value: any) => any} Function with value to transform\r\n */\r\n\r\nimport { pipe } from './pipe'\r\n\r\nexport function createPipe<A, B>(op1: (input: A) => B): (value: A) => B\r\n\r\nexport function createPipe<A, B, C>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n): (value: A) => C\r\n\r\nexport function createPipe<A, B, C, D>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n): (value: A) => D\r\n\r\nexport function createPipe<A, B, C, D, E>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n): (value: A) => E\r\n\r\nexport function createPipe<A, B, C, D, E, F>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n): (value: A) => F\r\n\r\nexport function createPipe<A, B, C, D, E, F, G>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n): (value: A) => G\r\n\r\nexport function createPipe<A, B, C, D, E, F, G, H>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n): (value: A) => H\r\n\r\nexport function createPipe<A, B, C, D, E, F, G, H, I>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n  op8: (input: H) => I,\r\n): (value: A) => I\r\n\r\nexport function createPipe<A, B, C, D, E, F, G, H, I, J>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n  op8: (input: H) => I,\r\n  op9: (input: I) => J,\r\n): (value: A) => J\r\n\r\nexport function createPipe<A, B, C, D, E, F, G, H, I, J, K>(\r\n  op1: (input: A) => B,\r\n  op2: (input: B) => C,\r\n  op3: (input: C) => D,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => F,\r\n  op6: (input: F) => G,\r\n  op7: (input: G) => H,\r\n  op8: (input: H) => I,\r\n  op9: (input: I) => J,\r\n  op10: (input: J) => K,\r\n): (value: A) => K\r\n\r\nexport function createPipe(...operations: ((input: any) => any)[]) {\r\n  return (value: any) => (pipe as any)(value, ...operations)\r\n}\r\n","/**\r\n * Apply async pipeline to a value\r\n * @date 18/10/2022 - 10:23:41\r\n *\r\n * @param {A} value Value that will transformed by pipeline\r\n * @param {...operations[]} operations Function or functions to pipeline\r\n * @returns Value transformed by asyncPipeline\r\n */\r\n\r\nexport function asyncPipe<A, B>(value: Promise<A> | A, op1: (input: A) => B): B\r\n\r\nexport function asyncPipe<A, B, C>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n): Promise<C>\r\n\r\nexport function asyncPipe<A, B, C, D>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n): Promise<D>\r\n\r\nexport function asyncPipe<A, B, C, D, E>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n): Promise<E>\r\n\r\nexport function asyncPipe<A, B, C, D, E, F>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n): Promise<F>\r\n\r\nexport function asyncPipe<A, B, C, D, E, F, G>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n): Promise<G>\r\n\r\nexport function asyncPipe<A, B, C, D, E, F, G, H>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n): Promise<H>\r\n\r\nexport function asyncPipe<A, B, C, D, E, F, G, H, I>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n  op8: (input: H) => Promise<I>,\r\n): Promise<I>\r\n\r\nexport function asyncPipe<A, B, C, D, E, F, G, H, I, J>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n  op8: (input: H) => Promise<I>,\r\n  op9: (input: I) => Promise<J>,\r\n): Promise<J>\r\n\r\nexport function asyncPipe<A, B, C, D, E, F, G, H, I, J, K>(\r\n  value: Promise<A> | A,\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n  op8: (input: H) => Promise<I>,\r\n  op9: (input: I) => Promise<J>,\r\n  op10: (input: J) => Promise<K>,\r\n): Promise<K>\r\n\r\nexport function asyncPipe(\r\n  value: any | Promise<any>,\r\n  ...operations: readonly ((input: any) => any)[]\r\n) {\r\n  return operations.reduce(async (acc, fn) => {\r\n    if (Promise.resolve(acc) === acc) {\r\n      return fn(await acc)\r\n    }\r\n    return fn(acc as Awaited<Promise<any>>)\r\n  }, value)\r\n}\r\n","/**\r\n * Create Apply async pipeline to a value\r\n * @date 08/10/2022 - 16:36:26\r\n *\r\n * @template K\r\n * @param {...Callback<K>[]} fns Function or functions to pipeline\r\n * @returns {(value: any) => any} Function with value to transform\r\n */\r\n\r\nimport { asyncPipe } from './asyncPipe'\r\n\r\nexport function createAsyncPipe<A, B>(\r\n  op1: (input: A) => B,\r\n): (value: Promise<A> | A) => B\r\n\r\nexport function createAsyncPipe<A, B, C>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n): (value: Promise<A> | A) => Promise<C>\r\n\r\nexport function createAsyncPipe<A, B, C, D>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n): (value: Promise<A> | A) => Promise<D>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n): (value: Promise<A> | A) => Promise<E>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E, F>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n): (value: Promise<A> | A) => Promise<F>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E, F, G>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => E,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n): (value: Promise<A> | A) => Promise<G>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E, F, G, H>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n): (value: Promise<A> | A) => Promise<H>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E, F, G, H, I>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n  op8: (input: H) => Promise<I>,\r\n): (value: Promise<A> | A) => Promise<I>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E, F, G, H, I, J>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n  op8: (input: H) => Promise<I>,\r\n  op9: (input: I) => Promise<J>,\r\n): (value: Promise<A> | A) => Promise<J>\r\n\r\nexport function createAsyncPipe<A, B, C, D, E, F, G, H, I, J, K>(\r\n  op1: (input: A) => Promise<B>,\r\n  op2: (input: B) => Promise<C>,\r\n  op3: (input: C) => Promise<D>,\r\n  op4: (input: D) => Promise<E>,\r\n  op5: (input: E) => Promise<F>,\r\n  op6: (input: F) => Promise<G>,\r\n  op7: (input: G) => Promise<H>,\r\n  op8: (input: H) => Promise<I>,\r\n  op9: (input: I) => Promise<J>,\r\n  op10: (input: J) => Promise<K>,\r\n): (value: Promise<A> | A) => Promise<K>\r\n\r\nexport function createAsyncPipe(\r\n  ...operations: readonly ((input: any) => any)[]\r\n) {\r\n  return (value: any | Promise<any>) => (asyncPipe as any)(value, ...operations)\r\n}\r\n","type MemoizedFn<T> = T & {\r\n  clear: () => void\r\n}\r\n\r\ntype Callback<K> = (...args: K[]) => K\r\n\r\n/**\r\n * Apply patterns memoization to a function\r\n * @date 08/10/2022 - 16:29:04\r\n *\r\n * @param {K} fn Function to apply memoization\r\n * @returns {MemoizedFn<ReturnType<Callback<K>>>} Memoized function\r\n */\r\nexport const memo = <K>(fn: K): MemoizedFn<ReturnType<Callback<K>>> => {\r\n  const cache = new Map<string, ReturnType<Callback<K>>>()\r\n\r\n  const memoizedFn = (...args: unknown[]): ReturnType<Callback<K>> => {\r\n    const key = JSON.stringify(args)\r\n\r\n    if (cache.has(key)) {\r\n      return cache.get(key) as ReturnType<Callback<K>>\r\n    }\r\n\r\n    const result = (fn as CallableFunction)(...args)\r\n    cache.set(key, result)\r\n\r\n    return result\r\n  }\r\n\r\n  Reflect.defineProperty(memoizedFn, 'clear', {\r\n    value: () => cache.clear(),\r\n  })\r\n\r\n  return memoizedFn as any\r\n}\r\n","type PartialFunction<T> = (...args: any[]) => T\r\n\r\n/**\r\n * Apply pattern Partial Application\r\n * @date 08/10/2022 - 16:30:22\r\n *\r\n * @param {PartialFunction<T>} fn Function to apply partial application\r\n * @param {...any[]} args args to apply in the Partial Function\r\n * @returns {PartialFunction<T>} Partial Function\r\n */\r\nexport const partialize = <T>(\r\n  fn: PartialFunction<T>,\r\n  ...args: any[]\r\n): PartialFunction<T> => fn.bind(null, ...args)\r\n","/**\r\n * Return a representational string of a given data type\r\n * @date 08/10/2022 - 17:20:28\r\n *\r\n * @param {unknown} elementToCheck Element to check type\r\n * @returns {String} type of element\r\n */\r\nexport const typeOf = (elementToCheck: unknown) => {\r\n  const stringType = Reflect.apply(\r\n    Object.prototype.toString,\r\n    elementToCheck,\r\n    [],\r\n  )\r\n  return stringType\r\n    .substring(stringType.indexOf(' ') + 1, stringType.indexOf(']'))\r\n    .toLowerCase()\r\n}\r\n","/**\r\n * Check if element is a primitive type\r\n * @date 04/10/2022 - 21:10:18\r\n *\r\n * @param {unknown} element Element to check\r\n * @returns {boolean} True => primitive | False => not primitive\r\n */\r\nexport const isPrimitive = (element: unknown) => !(Object(element) === element)\r\n","type Curry = <R extends (...args: any) => any>(fn: R) => Curried<ReturnType<R>>\r\n\r\n// type Curried<R> = (...args: any) => R | Curried<R>\r\ntype Curried<R> = (...args: any) => Curried2<R>\r\n\r\ntype Curried2<R> = R extends (...args: any) => any ? never : Curried<R>\r\n\r\nexport const curry: Curry = (fn) => {\r\n  return function curried(...args: any) {\r\n    if (fn.length <= args.length) {\r\n      return Reflect.apply(fn, null, args)\r\n    } else {\r\n      return (...args2: any) => {\r\n        return Reflect.apply(curried, null, args.concat(args2))\r\n      }\r\n    }\r\n  }\r\n}\r\n","type Func<TS extends any[], R> = (...args: TS) => R\r\n\r\n/**\r\n * This function implements debounce pattern\r\n * @date 11/10/2022 - 14:40:38\r\n *\r\n * @param {Func<any[], any>} fn Function to apply debounce\r\n * @param {number} [milliseconds=200] Time in milliseconds to schedule a function call\r\n * @returns {(...args: {}) => void} Function with debounce pattern\r\n */\r\nexport const debounce = (fn: Func<any[], any>, milliseconds = 200) => {\r\n  let timer: any = 0\r\n\r\n  return (...args: unknown[]) => {\r\n    if (timer) clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      Reflect.apply(fn, null, args)\r\n      timer = null\r\n    }, milliseconds)\r\n  }\r\n}\r\n","type Func<T> = (...args: any[]) => T\r\n\r\n/**\r\n * Create a function that can be called a certain number of times. If the number of calls is greater than the configured number of times, the undefined value will be returned.\r\n * @date 11/10/2022 - 14:42:51\r\n *\r\n * @template T\r\n * @param {Func<T>} fn Function that will be called\r\n * @param {*} [until=Infinity] Quantity of numbers that function can be called\r\n * @returns {(...args: {}) => Func<T>} Configured Function with takeUntil\r\n */\r\nexport const takeUntil =\r\n  <T>(fn: Func<T>, until = Infinity) =>\r\n  (...args: unknown[]): Func<T> | undefined =>\r\n    until-- > 0 ? (Reflect.apply(fn, null, args) as Func<T>) : undefined\r\n","import { isPrimitive } from './isPrimitive'\r\n\r\n/**\r\n * freeze recursively arrays and object structures\r\n * @date 11/10/2022 - 14:39:31\r\n *\r\n * @param {T} data Array or Object Structure\r\n * @returns {Readonly<T>} freezed data\r\n */\r\nexport const deepFreeze = <T extends object>(data: T): Readonly<T> => {\r\n  if (!isPrimitive(data)) {\r\n    if (isMap(data) || isSet(data)) {\r\n      freezeMapOrSet(data)\r\n      entries(data)\r\n    } else {\r\n      Reflect.ownKeys(data).forEach((key) => deepFreeze((data as any)[key]))\r\n    }\r\n  }\r\n\r\n  return Object.freeze(data)\r\n}\r\n\r\nconst errors = new Map([\r\n  [1, 'This object has been frozen and should not be mutated'],\r\n])\r\n\r\nconst isMap = (element: unknown): element is Map<unknown, unknown> =>\r\n  element instanceof Map\r\n\r\nconst isSet = (element: unknown): element is Set<unknown> =>\r\n  element instanceof Set\r\n\r\nconst entries = (data: Map<unknown, unknown> | Set<unknown>) =>\r\n  data.forEach((value: any) => deepFreeze(value))\r\n\r\nconst freezeMapOrSet = (mapOrSet: Map<unknown, unknown> | Set<unknown>) => {\r\n  if (isMap(mapOrSet)) {\r\n    freezeMap(mapOrSet)\r\n  } else {\r\n    freezeSet(mapOrSet)\r\n  }\r\n}\r\n\r\nconst die = () => {\r\n  throw Error(errors.get(1))\r\n}\r\n\r\nconst freezeMap = (map: Map<unknown, unknown>) => {\r\n  map.set = die\r\n  map.delete = die\r\n  map.clear = die\r\n}\r\n\r\nconst freezeSet = (set: Set<unknown>) => {\r\n  set.add = die\r\n  set.delete = die\r\n  set.clear = die\r\n}\r\n","import { typeOf } from './typeOf'\r\n\r\nfunction isObject(element: unknown): asserts element is object {\r\n  if (typeOf(element) !== 'object') {\r\n    throw new TypeError(`[${element}] should be an object`)\r\n  }\r\n}\r\n\r\nexport const mixin = <TResult = any>(\r\n  target: any,\r\n  ...objects: any[]\r\n): TResult => {\r\n  ;[target, ...objects].forEach(isObject)\r\n  objects.forEach((object) => cloneObj(target, object))\r\n  return target as TResult\r\n}\r\n\r\nconst cloneObj = (target: any, obj: any) => {\r\n  Reflect.ownKeys(obj).forEach((key) => {\r\n    if (typeof obj[key] === 'object') {\r\n      target[key] = {}\r\n      cloneObj(target[key], obj[key])\r\n    } else {\r\n      const descriptor = Object.getOwnPropertyDescriptor(obj, key)\r\n      if (descriptor) Reflect.defineProperty(target, key, descriptor)\r\n    }\r\n  })\r\n}\r\n","/**\r\n * Check if object is type of Interface in Type Parameter\r\n * @date 16/11/2022 - 19:20:18\r\n *\r\n * @export\r\n * @template Interface - Interface to check\r\n * @param {unknown} anObj - Object to check\r\n * @param {...(keyof Interface)[]} keys - keys of interface to check in object\r\n * @returns {anObj is Interface}\r\n */\r\nexport function checkInterface<Interface>(\r\n  anObj: unknown,\r\n  ...keys: (keyof Interface)[]\r\n): anObj is Interface {\r\n  if (anObj && typeof anObj === 'object' && keys.every((key) => key in anObj)) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n"],"mappings":"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","names":["isKeyOf","anObject","aKey","path","module","pathString","firstPath","paths","fullPath","log","args","pipe","value","operations","acc","fn","createPipe","operations","value","pipe","asyncPipe","value","operations","acc","fn","__async","createAsyncPipe","operations","value","asyncPipe","memo","fn","cache","memoizedFn","args","key","result","partialize","fn","args","typeOf","elementToCheck","stringType","isPrimitive","element","curry","fn","curried","args","args2","debounce","fn","milliseconds","timer","args","takeUntil","fn","until","args","deepFreeze","data","isPrimitive","isMap","isSet","freezeMapOrSet","entries","key","errors","element","value","mapOrSet","freezeMap","freezeSet","die","map","set","isObject","element","typeOf","mixin","target","objects","object","cloneObj","obj","key","descriptor","checkInterface","anObj","keys","key"]}