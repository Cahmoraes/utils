{"version":3,"sources":["../src/utils/path.ts","../src/utils/log.ts","../src/utils/pipeline.ts","../src/utils/asyncPipeline.ts","../src/utils/memo.ts","../src/utils/partialize.ts","../src/utils/typeOf.ts","../src/utils/isPrimitive.ts","../src/utils/curry.ts","../src/utils/debounce.ts","../src/utils/takeUntil.ts","../src/utils/deepFreeze.ts"],"names":["path","module","pathString","firstPath","paths","fullPath","log","args","pipeline","fns","value","acc","fn","asyncPipeline","memo","cache","memoizedFn","key","result","partialize","typeOf","elementToCheck","stringType","isPrimitive","element","curry","curried","args2","debounce","milliseconds","timer","takeUntil","until","deepFreeze","data"],"mappings":"AASO,IAAMA,EAAO,CAAIC,EAAiBC,IAAiC,CACxE,GAAI,CAACD,EAAQ,OAAO,KAEpB,GAAM,CAACE,KAAcC,CAAK,EAAIF,EAAW,MAAM,GAAG,EAC9CG,EAAWJ,EAAOE,GAEtB,QAAWH,KAAQI,EAAO,CACxB,GAAI,CAACC,EAAU,OAAO,KACtBA,EAAWA,EAASL,EACtB,CAEA,OAAOK,CACT,ECfO,IAAMC,EAAM,IAAIC,IAAoB,QAAQ,IAAI,GAAGA,CAAI,ECCvD,IAAMC,EACX,IAAIC,IACAC,GACFD,EAAI,OAAO,CAACE,EAAKC,IAAOA,EAAGD,CAAG,EAAGD,CAAK,ECAnC,IAAMG,EACX,IAAOJ,IACNC,GACCD,EAAI,OAAO,MAAOE,EAAKC,IACjB,QAAQ,QAAQD,CAAG,IAAMA,EACpBC,EAAG,MAAMD,CAAG,EAEdC,EAAGD,CAA0B,EACnCD,CAAK,ECLL,IAAMI,EAAWF,GAA+C,CACrE,IAAMG,EAAQ,IAAI,IAEZC,EAAa,IAAIT,IAA6C,CAClE,IAAMU,EAAM,KAAK,UAAUV,CAAI,EAE/B,GAAIQ,EAAM,IAAIE,CAAG,EACf,OAAOF,EAAM,IAAIE,CAAG,EAGtB,IAAMC,EAAUN,EAAwB,GAAGL,CAAI,EAC/C,OAAAQ,EAAM,IAAIE,EAAKC,CAAM,EAEdA,CACT,EAEA,eAAQ,eAAeF,EAAY,QAAS,CAC1C,MAAO,IAAMD,EAAM,MAAM,CAC3B,CAAC,EAEMC,CACT,ECxBO,IAAMG,EAAa,CACxBP,KACGL,IACoBK,EAAG,KAAK,KAAM,GAAGL,CAAI,ECNvC,IAAMa,EAAUC,GAA4B,CACjD,IAAMC,EAAa,QAAQ,MACzB,OAAO,UAAU,SACjBD,EACA,CAAC,CACH,EACA,OAAOC,EACJ,UAAUA,EAAW,QAAQ,GAAG,EAAI,EAAGA,EAAW,QAAQ,GAAG,CAAC,EAC9D,YAAY,CACjB,ECTO,IAAMC,EAAeC,GAAuB,OAAOA,CAAO,IAAMA,ECLhE,IAAMC,EAASb,GACb,SAASc,KAAWnB,EAAa,CACtC,OAAIK,EAAG,QAAUL,EAAK,OACb,QAAQ,MAAMK,EAAI,KAAML,CAAI,EAE5B,IAAIoB,IACF,QAAQ,MAAMD,EAAS,KAAMnB,EAAK,OAAOoB,CAAK,CAAC,CAG5D,ECDK,IAAMC,EAAW,CAAChB,EAAsBiB,EAAe,MAAQ,CACpE,IAAIC,EAAa,EAEjB,MAAO,IAAIvB,IAAoB,CACzBuB,GAAO,aAAaA,CAAK,EAC7BA,EAAQ,WAAW,IAAM,CACvB,QAAQ,MAAMlB,EAAI,KAAML,CAAI,EAC5BuB,EAAQ,IACV,EAAGD,CAAY,CACjB,CACF,ECTO,IAAME,EACX,CAAInB,EAAaoB,EAAQ,MACzB,IAAIzB,IACFyB,KAAU,EAAK,QAAQ,MAAMpB,EAAI,KAAML,CAAI,EAAgB,OCLxD,IAAM0B,EAAgCC,IACtCX,EAAYW,CAAI,GACnB,QAAQ,QAAQA,CAAI,EAAE,QAASjB,GAAQgB,EAAWC,EAAKjB,EAAI,CAAC,EAGvD,OAAO,OAAOiB,CAAI","sourcesContent":["/**\n * Resolve internal Objects and Arrays paths. Return null when path not exists.\n * @date 08/10/2022 - 16:32:10\n *\n * @template T\n * @param {unknown} module - Object or Array\n * @param {string} pathString Path to property: 'addresses.0.street'\n * @returns {(T | null)} Existing property or null if none\n */\nexport const path = <T>(module: unknown, pathString: string): T | null => {\n  if (!module) return null\n\n  const [firstPath, ...paths] = pathString.split('.')\n  let fullPath = module[firstPath]\n\n  for (const path of paths) {\n    if (!fullPath) return null\n    fullPath = fullPath[path]\n  }\n\n  return fullPath\n}\n","/**\n * Log values\n * @date 08/10/2022 - 16:27:16\n *\n * @param {...unknown[]} args Parameters to log\n */\nexport const log = (...args: unknown[]) => console.log(...args)\n","/**\n * Apply pipeline to a value\n * @date 08/10/2022 - 16:35:18\n *\n * @param {...CallableFunction[]} fns Function or functions to pipeline\n * @returns {<T>(value: T) => any} Function with value to transform\n */\nexport const pipeline =\n  (...fns: CallableFunction[]) =>\n  <T>(value: T) =>\n    fns.reduce((acc, fn) => fn(acc), value)\n","type Callback<T> = (value: T) => T | Promise<T>\n\n/**\n * Apply async pipeline to a value\n * @date 08/10/2022 - 16:36:26\n *\n * @template K\n * @param {...Callback<K>[]} fns Function or functions to pipeline\n * @returns {(value: any) => any} Function with value to transform\n */\nexport const asyncPipeline =\n  <K>(...fns: Callback<K>[]) =>\n  (value: K | Promise<K>) =>\n    fns.reduce(async (acc, fn) => {\n      if (Promise.resolve(acc) === acc) {\n        return fn(await acc)\n      }\n      return fn(acc as Awaited<Promise<K>>)\n    }, value)\n","type MemoizedFn<T> = T & {\n  clear: () => void\n}\n\ntype Callback<K> = (...args: K[]) => K\n\n/**\n * Apply patterns memoization to a function\n * @date 08/10/2022 - 16:29:04\n *\n * @param {K} fn Function to apply memoization\n * @returns {MemoizedFn<ReturnType<Callback<K>>>} Memoized function\n */\nexport const memo = <K>(fn: K): MemoizedFn<ReturnType<Callback<K>>> => {\n  const cache = new Map<string, ReturnType<Callback<K>>>()\n\n  const memoizedFn = (...args: unknown[]): ReturnType<Callback<K>> => {\n    const key = JSON.stringify(args)\n\n    if (cache.has(key)) {\n      return cache.get(key) as ReturnType<Callback<K>>\n    }\n\n    const result = (fn as CallableFunction)(...args)\n    cache.set(key, result)\n\n    return result\n  }\n\n  Reflect.defineProperty(memoizedFn, 'clear', {\n    value: () => cache.clear(),\n  })\n\n  return memoizedFn as any\n}\n","type PartialFunction<T> = (...args: any[]) => T\n\n/**\n * Apply pattern Partial Application\n * @date 08/10/2022 - 16:30:22\n *\n * @param {PartialFunction<T>} fn Function to apply partial application\n * @param {...any[]} args args to apply in the Partial Function\n * @returns {PartialFunction<T>} Partial Function\n */\nexport const partialize = <T>(\n  fn: PartialFunction<T>,\n  ...args: any[]\n): PartialFunction<T> => fn.bind(null, ...args)\n","/**\n * Return a representational string of a given data type\n * @date 08/10/2022 - 17:20:28\n *\n * @param {unknown} elementToCheck Element to check type\n * @returns {String} type of element\n */\nexport const typeOf = (elementToCheck: unknown) => {\n  const stringType = Reflect.apply(\n    Object.prototype.toString,\n    elementToCheck,\n    [],\n  )\n  return stringType\n    .substring(stringType.indexOf(' ') + 1, stringType.indexOf(']'))\n    .toLowerCase()\n}\n","/**\n * Check if element is a primitive type\n * @date 04/10/2022 - 21:10:18\n *\n * @param {unknown} element Element to check\n * @returns {boolean} True => primitive | False => not primitive\n */\nexport const isPrimitive = (element: unknown) => !(Object(element) === element)\n","type Func<T extends any[]> = (...args: T) => any\n\nexport const curry = (fn: Func<any>): Func<any[]> => {\n  return function curried(...args: any[]) {\n    if (fn.length <= args.length) {\n      return Reflect.apply(fn, null, args)\n    } else {\n      return (...args2: unknown[]) => {\n        return Reflect.apply(curried, null, args.concat(args2))\n      }\n    }\n  }\n}\n","type Func<TS extends any[], R> = (...args: TS) => R\n\n/**\n * This function implements debounce pattern\n * @date 11/10/2022 - 14:40:38\n *\n * @param {Func<any[], any>} fn Function to apply debounce\n * @param {number} [milliseconds=200] Time in milliseconds to schedule a function call\n * @returns {(...args: {}) => void} Function with debounce pattern\n */\nexport const debounce = (fn: Func<any[], any>, milliseconds = 200) => {\n  let timer: any = 0\n\n  return (...args: unknown[]) => {\n    if (timer) clearTimeout(timer)\n    timer = setTimeout(() => {\n      Reflect.apply(fn, null, args)\n      timer = null\n    }, milliseconds)\n  }\n}\n","type Func<T> = (...args: any[]) => T\n\n/**\n * Create a function that can be called a certain number of times. If the number of calls is greater than the configured number of times, the undefined value will be returned.\n * @date 11/10/2022 - 14:42:51\n *\n * @template T\n * @param {Func<T>} fn Function that will be called\n * @param {*} [until=Infinity] Quantity of numbers that function can be called\n * @returns {(...args: {}) => Func<T>} Configured Function with takeUntil\n */\nexport const takeUntil =\n  <T>(fn: Func<T>, until = Infinity) =>\n  (...args: unknown[]): Func<T> | undefined =>\n    until-- > 0 ? (Reflect.apply(fn, null, args) as Func<T>) : undefined\n","import { isPrimitive } from './isPrimitive'\n\n/**\n * freeze recursively arrays and object structures\n * @date 11/10/2022 - 14:39:31\n *\n * @param {T} data Array or Object Structure\n * @returns {T} freezed data\n */\nexport const deepFreeze = <T extends object>(data: T): T => {\n  if (!isPrimitive(data)) {\n    Reflect.ownKeys(data).forEach((key) => deepFreeze(data[key]))\n  }\n\n  return Object.freeze(data)\n}\n"]}