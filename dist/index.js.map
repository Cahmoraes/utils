{"version":3,"sources":["../src/index.ts","../src/utils/path.ts","../src/utils/log.ts","../src/utils/pipeline.ts","../src/utils/asyncPipeline.ts","../src/utils/memo.ts","../src/utils/partialize.ts"],"sourcesContent":["export { path } from './utils/path'\nexport { log } from './utils/log'\nexport { pipeline } from './utils/pipeline'\nexport { asyncPipeline } from './utils/asyncPipeline'\nexport { memo } from './utils/memo'\nexport { partialize } from './utils/partialize'\n","export const path = <T>(module: unknown, pathString: string): T | null => {\n  if (!module) return null\n\n  const [firstPath, ...paths] = pathString.split('.')\n  let fullPath = module[firstPath]\n\n  for (const path of paths) {\n    if (!fullPath) return null\n    fullPath = fullPath[path]\n  }\n\n  return fullPath\n}\n","export const log = (...args: unknown[]) => console.log(...args)\n","export const pipeline =\n  (...fns: CallableFunction[]) =>\n  <T>(value: T) =>\n    fns.reduce((acc, fn) => fn(acc), value)\n","type Callback<K> = <T>(value: T) => K | Promise<K>\n\nexport const asyncPipeline =\n  <K>(...fns: Callback<K>[]) =>\n  (value: K | Promise<K>) =>\n    fns.reduce(async (acc, fn) => {\n      if (Promise.resolve(acc) === acc) {\n        return fn(await acc)\n      }\n      return fn(acc)\n    }, value)\n","type MemoizedFn<T> = T & {\n  clear: () => void\n}\n\ntype Callback<K> = (...args: K[]) => K\n\nexport const memo = <K>(fn: K): MemoizedFn<ReturnType<Callback<K>>> => {\n  const cache = new Map<string, ReturnType<Callback<K>>>()\n\n  const memoizedFn = (...args: unknown[]): ReturnType<Callback<K>> => {\n    const key = JSON.stringify(args)\n\n    if (cache.has(key)) {\n      return cache.get(key) as ReturnType<Callback<K>>\n    }\n\n    const result = (fn as CallableFunction)(...args)\n    cache.set(key, result)\n\n    return result\n  }\n\n  Reflect.defineProperty(memoizedFn, 'clear', {\n    value: () => cache.clear(),\n  })\n\n  return memoizedFn as any\n}\n","type PartialFunction<T> = (...args: T[]) => T\n\nexport const partialize = <T>(\n  fn: PartialFunction<T>,\n  ...args: any[]\n): PartialFunction<T> => fn.bind(null, ...args)\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,mBAAAE,EAAA,QAAAC,EAAA,SAAAC,EAAA,eAAAC,EAAA,SAAAC,EAAA,aAAAC,IAAA,eAAAC,EAAAR,GCAO,IAAMS,EAAO,CAAIC,EAAiBC,IAAiC,CACxE,GAAI,CAACD,EAAQ,OAAO,KAEpB,GAAM,CAACE,KAAcC,CAAK,EAAIF,EAAW,MAAM,GAAG,EAC9CG,EAAWJ,EAAOE,GAEtB,QAAWH,KAAQI,EAAO,CACxB,GAAI,CAACC,EAAU,OAAO,KACtBA,EAAWA,EAASL,EACtB,CAEA,OAAOK,CACT,ECZO,IAAMC,EAAM,IAAIC,IAAoB,QAAQ,IAAI,GAAGA,CAAI,ECAvD,IAAMC,EACX,IAAIC,IACAC,GACFD,EAAI,OAAO,CAACE,EAAKC,IAAOA,EAAGD,CAAG,EAAGD,CAAK,ECDnC,IAAMG,EACX,IAAOC,IACNC,GACCD,EAAI,OAAO,MAAOE,EAAKC,IACjB,QAAQ,QAAQD,CAAG,IAAMA,EACpBC,EAAG,MAAMD,CAAG,EAEdC,EAAGD,CAAG,EACZD,CAAK,ECJL,IAAMG,EAAWC,GAA+C,CACrE,IAAMC,EAAQ,IAAI,IAEZC,EAAa,IAAIC,IAA6C,CAClE,IAAMC,EAAM,KAAK,UAAUD,CAAI,EAE/B,GAAIF,EAAM,IAAIG,CAAG,EACf,OAAOH,EAAM,IAAIG,CAAG,EAGtB,IAAMC,EAAUL,EAAwB,GAAGG,CAAI,EAC/C,OAAAF,EAAM,IAAIG,EAAKC,CAAM,EAEdA,CACT,EAEA,eAAQ,eAAeH,EAAY,QAAS,CAC1C,MAAO,IAAMD,EAAM,MAAM,CAC3B,CAAC,EAEMC,CACT,ECzBO,IAAMI,EAAa,CACxBC,KACGC,IACoBD,EAAG,KAAK,KAAM,GAAGC,CAAI","names":["src_exports","__export","asyncPipeline","log","memo","partialize","path","pipeline","__toCommonJS","path","module","pathString","firstPath","paths","fullPath","log","args","pipeline","fns","value","acc","fn","asyncPipeline","fns","value","acc","fn","memo","fn","cache","memoizedFn","args","key","result","partialize","fn","args"]}